//let a = text.a(n+2);
//console.a.b.c(a.b);
//import process from 'node:process';
//it -> n + 1;
//[* 0, lamnda]  >> [! 50] >> [? n -> n/2];
[* 0, test];
//let a = [* 0, n -> n + 1];
//[* 0, n -> n + 1] >> [? printIt];
//test >> [? printIt];
//const some_list = [1, [2, 3, [4]], 'hola'];
const a = [2][3];


/*
AST:
expr(
	pipe(	
		iterate(int(0),expr(id(lamnda))),pipe(cut(int(50)),pipe(filter(expr(arrow(id(n),expr(id(n)/literal(int(2)))))),[]))
	)
)

AST:
expr(
	pipe(
		cal(
			iterate(
				int(0),
				expr(
					arrow(
						id(n),
						id(n)+literal(int(1))
					)
				)
			)
		),
		[]
	)
)
iterate(0,n => n + 1);

AST:
expr(
	pipe(
		cal(
			iterate(
				int(0),
				expr(
					arrow(
						id(n),
						expr(
							id(n)+literal(int(1))
						)
					)
				)
			)
		),
		[]
	)
)
JS:
iterate(0,n => n + 1);



AST:
expr(
	pipe(
		id(test),
		pipe(
			cal(
				filter(id(printIt))
			),
			[]
		)
	)
)
JS:
test.filter(printIt);

AST:
expr(
	pipe(
		cal(
			iterate(int(0),id(n),expr(id(n)+literal(int(1))))
		),
		pipe(
			cal(
				cut(int(50))
			),
			[]
		)
	)
)
JS:
iterate(0,n => n + 1).cut(50);


AST:
expr(
	pipe(
		cal(
			iterate(
				int(0),
				id(n),
				expr(id(n)+literal(int(1)))
			)
		),
		pipe(
			cal(
				cut(int(50))
			),
			pipe(
				cal(
					filter(
						id(n),
						expr(id(n)/literal(int(2)))
					)
				),
				[]
			)
		)
	)
)
JS:
iterate(0,n => n + 1).cut(50).filter(n => n/2);



AST:
declaration(
	const,id(nats2),
	pipe(
		id(nats),
		pipe(
			cal(
				map(
					id(n),
					expr(id(n))
				)
			),
			[]
		)
	)
)
JS:
const nats2 = nats.map( n -> n );




expr(
	pipe(
		cal(
			iterate(
				int(0),
				expr(
					arrow(
						id(n),
						id(n)+literal(int(1))
					)
				)
			)
		),
		[]
	)
)


falta generator de lista
falta terminar generadores de map, fiter y eso
falta generador if funcional
falta not
falta matris [][]
falta identificador[1];
faltan modulos

*/

